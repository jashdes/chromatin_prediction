function [pos, sigma] = findSpots(image,template)
% based on track_7x7_func by GHolzwarth 2018_06_09

% convert inputs to uint8
image = im2uint8(image);
template = im2uint8(template);

pause off;
        
    numSpotsX = 7;      % number of spots along x direction
    numSpotsY = 7;      % number of spots along y direction
    numSpots   = (numSpotsX)*(numSpotsY);

% STEP 11.1 obtain metadata from image
[numRows, numCols]   = size(image);

rr_max = numSpots;
        
% STEP 11.2  Set width, define ROI, set width2, define ROI2
width = 8;  % use with template-based ROI centers
numColsROI = 2*width + 1;   % 61
numRowsROI = 2*width + 1;

width2 = 4; % use with CL centered ROI2

% STEP 12.1 construct pedestal for each frame 
SE = offsetstrel('ball',5,10);
     %SE = offsetstrel('ball',R,H) creates a nonflat, ball-shaped
     % structuring element whose radius in the X-Y plane is R and whose
     % maximum offset height is H. For improved performance,
     % offsetstrel approximates this shape by a sequence of eight nonflat
     % line-shaped structuring elements.
     
pedestal = imopen(image, SE);
    
% STEP 12.4 Subtract pedestalFilt from im_array

im_minus_pedestal = image - pedestal;

if (im_minus_pedestal<0)
       im_minus_pedestal=0;
end    % end if
    
% STEP 13  Apply bpass filter to im-minus-pedestal

im_filtered = bpass_plusEdges(im_minus_pedestal,1,10,0.05);

% STEP 14.1 set up registration

% STEP 14.15 Scale intensities of template and image to 1.0   
    Imax_template    = max(max(template));
       template_scaled = template./Imax_template;
    Imax_im_filtered = max(max(im_filtered));
       im_filtered_scaled = im_filtered./Imax_im_filtered;

%  STEP 14.3 register
[optimizer, metric]  = imregconfig('multimodal');
optimizer.MaximumIterations = 500; 
optimizer.InitialRadius = 0.002;


% STEP 14.4 Find tform and apply it to template
tform = imregtform(template_scaled,im_filtered_scaled,'affine',optimizer,metric,'DisplayOptimization',0);
tform_array = maketform('affine',tform.T);
       
% STEP 15.1 Hard-code the original centers for 7x7 template in 181 x 181 image

% make sure this dimension assumption is correct
assert(min(size(image) == [181,181]));


  %  Hard-code centers based on pattern generated by DOE in Olympus
        % using 181 x 181 ROI with center spot at (91,91) and spacing =
        % 16.67. Check! this doesn't compute correctly

C=zeros(49,2);  %col2=1, x; col2 = 2, y

C(:,1) = [44 44 44 44 44 44 44 60 60 60 60 60 60 60 75 75 75 75 75 75 75 91 91 91 91 91 91 91 107 107 107 107 107 107 107 122 122 122 122 122 122 122 138 138 138 138 138 138 138];
C(:,2) = [44 60 75 91 107 122 138 44 60 75 91 107 122 138 44 60 75 91 107 122 138 44 60 75 91 107 122 138 44 60 75 91 107 122 138 44 60 75 91 107 122 138 44 60 75 91 107 122 138];
u = C(:,1)';    % u is 1 x 49 array
v = C(:,2)';    % v     "
% transform the centers
[xm,ym] = tformfwd(tform_array,u,v);  % xm is 1 x 49 array of x values of centers
                                     % use xm in place of C(:,1)
                                     % use ym in place of C(:,2)
xmr = round(xm + 1); 
ymr = round(ym + 1);
    
 
% STEP 15.2 construct 49 masks to assign a number to each spot
M     = zeros(numRows,numCols,49);
im_filtMasked     = zeros(numRows,numCols,49);  % new June 2017

for rr = 1:49 % end at L127
    M((ymr(1,rr)-width):(ymr(1,rr) + width),(xmr(1,rr)-width):(xmr(1,rr)+width),rr) = 1; 
   % M is 0 except in ROI
    mask_double = double(M);  
    im_filtMasked(:,:,rr)     = im_filtered.*mask_double(:,:,rr);  % 181 x 181 x numSpots
end  % end of rr loop

% STEP 15.3 Set up goodSpot matrix
goodSpot = ones(49,5); %  
    % col    1           2           3          4       5
    %       rr  goodAmplitude   max(resnorm)  noNaN  decision 
    % goodAmplitude = 1 means bright spot; goodAmplitude = 0 means weak spot
rr_array = linspace(1,49,49);
goodSpot(:,1) = rr_array';

% STEP 16.1 Find center of each spot using pkfnd_7x7_original
out_temp_reg = zeros(numSpots,2);  % consider cleanup. 
for rr = 1:numSpots
    th_percent = .05;
    [ goodSpot ] = check_spotAmplitude( im_filtMasked(:,:,rr),th_percent,rr,Imax_im_filtered,goodSpot);
    Imax = max(max(im_filtMasked(:,:,rr)));
    if(goodSpot(rr,2)==1)
        [out_no_rr, goodSpot] = pkfnd_7x7_original(im_filtMasked(:,:,rr),0.9*Imax,3,rr,goodSpot);
    else
        out_no_rr(1) = NaN;
        out_no_rr(2) = NaN;
    end
      
    out_temp_reg(rr,1)=out_no_rr(1,1);  % "out_temp_reg" replaces "out"
    out_temp_reg(rr,2)=out_no_rr(1,2);
        
end

% STEP 16.3 define ROI around each spot in template
    % fprintf('STEP 16.3 define ROI around each spot\n');
ROI_template = zeros(numSpots,4);  % rows = spot#, col1 = ii_initial; col2 = ii_final;
                    %               col3 = jj_initial; col4 = jj-final;


 
 for rr = 1:rr_max % rr is ROINumber L243-339
    ROI_template(rr,1) = round(xmr(1,rr)-width); % x_i along Columns
    ROI_template(rr,2) = round(xmr(1,rr)+width); % x_f along Columns 
    ROI_template(rr,3) = round(ymr(1,rr)-width); % y_i down ROWS
    ROI_template(rr,4) = round(ymr(1,rr)+width); % y_f down ROWS 
    
  end  % end of 'for rr = 1:rr_max' L 277-402

% STEP 16.4 construct ROI_im_filtdata
    % fprintf('STEP 16.4 ROI construction\n');
ROIdata_template =  zeros(numRowsROI,  numColsROI,  49); % 2*width + 1
for rr = 1:numSpots
    if(goodSpot(rr,2)==1)
        row_begin = ROI_template(rr,3);  % y_i
        row_end   = ROI_template(rr,4);  % y_f
        col_begin = ROI_template(rr,1);  % x_i 
        col_end   = ROI_template(rr,2);  % y_f
        ROIdata_template(:,:,rr)= im_filtered(row_begin:row_end,col_begin:col_end);
    end
end 

% STEP 18.0 Set up main loop to fit 2D Gaussian to each peak.
    % cols:  col1 = spot(rr); col2 = frame(kk); col3 = x; col4 = y; col5 = t
    % col 11=flag for strong/weak spot, col12 = sigma_x, col13=sigma_y.



% % ***********************************************************************
% % ***********    MAIN LOOPS over spot=rr                   **************
% % **********    subpixel localization of each spot     ******************
% % ***********************************************************************

% STEP 18.1 MAIN LOOPS fitting 2D Gaussian to each spot in each frame. 
dataSmall = zeros(numColsROI,numRowsROI);

    % goodSpot = zeros(49,5); %
        % col    1           2                3               4            5
        %       rr  goodAmplitude    max(resnorm) noNaN    decision 
        % goodAmplitude = 1 means bright spot; goodAmplitude = 0 means weak spot
    % rr_array = linspace(1,49,49);
    % goodSpot(:,1) = rr_array';

% *************   *************   ***************   **************   ******
% *************   Main loops over rr and kk         **************   ******
% *************   *************   ***************   **************   ******

% initialize position and sigma matrices
pos = zeros(numSpots, 2);
sigma = zeros(numSpots, 2);

for rr = 1:numSpots
    if(goodSpot(rr,2)==1)
        % fprintf('kk = %s\n',num2str(kk));
        dataSmall = ROIdata_template(:,:,rr);
            %         figure (20)   % *****************************************  Fig 20
            %          set(gcf,'units','normalized','outerposition',[0 0 1 1 ]);
            %          imshow(dataSmall,[]);hold on;
            %              title(['Fig 20, dataSmall,rr = ',num2str(rr),', kk =  ',num2str(kk)]);
            %              xlabel('x (pix)');
            %              ylabel('y (pix)');
            %          pause(PT1)    
    end
         
% STEP 18.2. Locate intensity centroid for this spot, using pkfnd_1_spot,
                % to initialize parameter (A0).
nnn = 14;  % nnn = figure number
[CL, ~, maxIntensity] = pkfnd_1_spot(dataSmall,nnn); % uses Center-of-Mass
    
if (maxIntensity > 0.1*Imax_im_filtered)  %
    goodSpot(rr,2)=1;
else
        % fprintf('L491 track_7x7, inside else\n');
        CL(1)=NaN;
        CL(2)=NaN;
       goodSpot(rr,2) = 0;
end    
%               
         
          b = dataSmall;  % was ROIdata(:,:,kk,rr); changed to dataSmall2 Nov 1 2016 ; changed to dataSmall 4/2017
         f=b; % skip bpass step. Image filtered earlier           
% % ****************************************************************
% STEP 18.3 Fit 2D Gaussian to filtered peak    ***********
% % ****************************************************************dataSmall
% STEP 18.31  set up grid and ROI (patch2)on which Gaussian is evaluated.
        aa = width;  % width of ROI for Gaussian fit, 7x7 code
       [x, y]=meshgrid(1:2*aa+1,1:2*aa+1);  
       f_scaled = f./(max(max(f)));
       patch2 = f_scaled; % should get rid of the "patch2" terminology. Not helpful

% STEP 18.4 BKGD SUBTRACTION, flat
% compute bkgd from 4 edges of patch2 and subtract
        meanbackground=mean([mean(patch2(1,:)) mean(patch2(2*width2+1,:)) mean(patch2(:,1)) mean(patch2(:,2*width2+1))]);
            %meanbackground=mean([mean(patch2(1,:)) mean(patch2(2*aa+1,:)) mean(patch2(:,1)) mean(patch2(:,2*aa+1))]);
        patch2=patch2-meanbackground;
%                
% define the anonymous 2D Gaussian fit function MINUS experimental data
        myfun = @(A) A(1)*exp(-(((x(:)-A(2)).^2/(2*A(3)^2))+((y(:)-A(4)).^2/(2*A(5)^2))))-patch2(:);
             % A(1) = amplitude.   patch2 is intensity of filtered image -bkgd
             % A(2) = x-center
             % A(3) = sigma x
             % A(4) = y-center
             % A(5) = sigma y
 % define the 2D Gaussian fit function alone.
    % need x(:) and y(:)
 
%      im_fit(:,:)= A(1)*exp(-(((x(:)-A(2)).^2/(2*A(3)^2))+((y(:)-A(4)).^2/(2*A(5)^2))));
            
% STEP 18.5 % find spot in frame 1
% ***   ***************   **************   **********
% ***        FIT Gaussian to spot rr in frame 1     **********
% ***   ***************   **************   **********
 if (goodSpot(rr,2))
           A0=[max(max(patch2));CL(2);2;CL(1);2];
           options = optimoptions('lsqnonlin','Algorithm','levenberg-marquardt',...
             'OptimalityTolerance',1e-7,'Display','off');
           lb = []; 
           ub = []; 

    % CALL lsqnonlin **************    ******************   *************       
       fitparams = lsqnonlin(myfun,A0,lb,ub,options);
       
   %   Calculate spot positions by

    %   getting the spot position from the template
    pos(rr,1) = ymr(rr);
    pos(rr,2) = xmr(rr);

    %   adding the offset obtained from fitting
    
    % x-axis
    pos(rr,1) = pos(rr,1) - width + fitparams(4);
    sigma(rr,1) = fitparams(5);
    
    % y-axis
    pos(rr,2) = pos(rr,2) - width + fitparams(2);
    sigma(rr,2) = fitparams(3);

    %   and removing the bias of 1 introduced in xmr and ymr calculations
    pos(rr,:) = pos(rr,:) - 1;
 else
     pos(rr,:) = NaN;
     sigma(rr,:) = NaN;
 end 
    
end

end
